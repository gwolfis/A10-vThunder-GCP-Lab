#!/usr/bin/env bash
set -euo pipefail

ENV_FILE="/etc/a10-failover/env"

if [[ -f "${ENV_FILE}" ]]; then
  # shellcheck disable=SC1090
  source "${ENV_FILE}"
else
  echo "ERROR: ${ENV_FILE} not found"
  exit 1
fi

PROJECT="$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/project/project-id || true)"
if [[ -z "${PROJECT}" ]]; then
  echo "ERROR: Could not determine project ID from metadata"
  exit 1
fi

gcloud config set project "${PROJECT}" >/dev/null

if [[ -z "${REGION:-}" ]]; then
  ZONE_PATH="$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/zone || true)"
  ZONE_NAME="${ZONE_PATH##*/}"
  REGION="${ZONE_NAME%-*}"
fi

if [[ -z "${PRIMARY_TI:-}" || -z "${PRIMARY_ZONE:-}" || -z "${SECONDARY_TI:-}" || -z "${SECONDARY_ZONE:-}" ]]; then
  echo "ERROR: PRIMARY_TI PRIMARY_ZONE SECONDARY_TI SECONDARY_ZONE must be set in ${ENV_FILE}"
  exit 1
fi

if [[ -z "${VIPS_TO_CHECK:-}" ]]; then
  echo "ERROR: VIPS_TO_CHECK must be set in ${ENV_FILE}"
  exit 1
fi

read -r -a VIPS_ARR <<< "${VIPS_TO_CHECK}"

MAX_ATTEMPTS="${MAX_ATTEMPTS:-3}"
SLEEP_SECONDS="${SLEEP_SECONDS:-2}"
LOOP_INTERVAL_SECONDS="${LOOP_INTERVAL_SECONDS:-30}"
COOLDOWN_AFTER_FAILOVER_SECONDS="${COOLDOWN_AFTER_FAILOVER_SECONDS:-180}"
HEALTH_POLICY="${HEALTH_POLICY:-ANY}"
FW_FILTER="${FW_FILTER:-name=vip-web-fr}"

health_check() {
  local policy_upper
  policy_upper=$(echo "${HEALTH_POLICY}" | tr '[:lower:]' '[:upper:]')

  if [[ "${policy_upper}" == "ANY" ]]; then
    local any_healthy=0

    for vip in "${VIPS_ARR[@]}"; do
      local vip_ok=0
      for ((i=1; i<=MAX_ATTEMPTS; i++)); do
        if curl -sk --max-time 3 "${vip}" >/dev/null; then
          vip_ok=1
          break
        fi
        sleep "${SLEEP_SECONDS}"
      done
      if [[ "${vip_ok}" -eq 1 ]]; then
        any_healthy=1
        break
      fi
    done

    if [[ "${any_healthy}" -eq 1 ]]; then
      return 1
    fi

    return 0
  fi

  if [[ "${policy_upper}" == "ALL" ]]; then
    local all_healthy=1

    for vip in "${VIPS_ARR[@]}"; do
      local vip_ok=0
      for ((i=1; i<=MAX_ATTEMPTS; i++)); do
        if curl -sk --max-time 3 "${vip}" >/dev/null; then
          vip_ok=1
          break
        fi
        sleep "${SLEEP_SECONDS}"
      done
      if [[ "${vip_ok}" -eq 0 ]]; then
        all_healthy=0
        break
      fi
    done

    if [[ "${all_healthy}" -eq 1 ]]; then
      return 1
    fi

    return 0
  fi

  echo "Unknown HEALTH_POLICY '${HEALTH_POLICY}' expected ANY or ALL"
  return 1
}

perform_failover() {
  local rules
  rules=$(gcloud compute forwarding-rules list \
    --regions="${REGION}" \
    --filter="${FW_FILTER}" \
    --format='value(name)')

  if [[ -z "${rules}" ]]; then
    echo "No forwarding rules found for filter ${FW_FILTER}"
    return 0
  fi

  local first_rule
  first_rule=$(echo "${rules}" | head -n1)

  local first_target
  first_target=$(gcloud compute forwarding-rules describe "${first_rule}" \
    --region="${REGION}" \
    --format='value(target)')

  local to_ti to_zone

  if [[ "${first_target}" == *"/targetInstances/${PRIMARY_TI}" ]]; then
    to_ti="${SECONDARY_TI}"
    to_zone="${SECONDARY_ZONE}"
  elif [[ "${first_target}" == *"/targetInstances/${SECONDARY_TI}" ]]; then
    to_ti="${PRIMARY_TI}"
    to_zone="${PRIMARY_ZONE}"
  else
    echo "ERROR: Could not determine active side from target ${first_target}"
    return 1
  fi

  for rule in ${rules}; do
    local current_target
    current_target=$(gcloud compute forwarding-rules describe "${rule}" \
      --region="${REGION}" \
      --format='value(target)')

    if [[ "${current_target}" == *"/targetInstances/${to_ti}" ]]; then
      continue
    fi

    gcloud compute forwarding-rules set-target "${rule}" \
      --region="${REGION}" \
      --target-instance="${to_ti}" \
      --target-instance-zone="${to_zone}"
  done
}

echo "A10 failover watcher starting in project ${PROJECT} region ${REGION}"

while true; do
  if health_check; then
    perform_failover
    sleep "${COOLDOWN_AFTER_FAILOVER_SECONDS}"
  else
    sleep "${LOOP_INTERVAL_SECONDS}"
  fi
done
